{"Time": {"convertTimeFromTicks": {"sections": {"Inputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}, "Outputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "E": "Garbage", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}}, "name": "convertTimeFromTicks", "description": "Convert from ticks in seconds to time. The epoch is January 1st, 1997 (a Wednesday)"}, "getTime": {"sections": {"Outputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "E": "Garbage", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}}, "name": "getTime", "description": "Gets the current time."}, "setClock": {"sections": {"Inputs": {"DE": "Upper word of a 32-bit tick value", "HL": "Lower word of a 32-bit tick value"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure"}}, "name": "setClock", "description": "Sets the internal clock."}, "convertTimeToTicks": {"sections": {"Inputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}, "Outputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}}, "name": "convertTimeToTicks", "description": "Converts a time structure to seconds since epoch."}, "getClock": {"sections": {"Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure", "DE": "Upper word of the 32-bit tick value", "HL": "Lower word of the 32-bit tick value"}}, "name": "getClock", "description": "Gets the internal clock."}}, "Cryptography": {"sha1Clean": {"sections": {"Inputs": {"IX": "location of allocated block"}}, "name": "sha1Clean", "description": "Safely deallocates a SHA1 state block allocated by sha1Init."}, "crc16": {"sections": {"Inputs": {"HL": "Pointer to data", "BC": "Size of data"}, "Outputs": {"DE": "CRC of data"}}, "name": "crc16", "description": "Performs a Cyclic Redundancy Check on data."}, "sha1Init": {"sections": {"Outputs": {"A": "Error code (on failure)", "IX": "location of allocated block (on success)", "Z": "Set on success, reset on failure"}}, "name": "sha1Init", "description": "Allocates a memory block to keep the state and result of a SHA1 hash operation.  The result is kept in the first 20 bytes of the allocated block.  You must use [[sha1Clean]] to deallocate the block; simply using [[free]] will result in a memory leak!"}, "sha1AddByte": {"sections": {"Inputs": {"A": "Byte to add", "IX": "location of SHA1 state block"}}, "name": "sha1AddByte", "description": "Adds a single byte to the SHA1 hash input stream. Call this function once for each byte in the input stream, then call [[sha1Pad]]."}, "sha1Pad": {"sections": {"Inputs": {"IX": "location of SHA1 state block"}}, "name": "sha1Pad", "description": "Finishes the SHA1 computation by appending the required bits to the input.  Call this routine once after calling [[sha1AddByte]] for each input byte.  After this routine, the 8 bytes pointed to by IX will contain the big-endian SHA1 hash."}, "sha1AddRange": {"sections": {"Inputs": {"IX": "location of SHA1 state block", "HL": "location of range to add", "BC": "number of bytes to add"}}, "name": "sha1AddRange", "description": "Adds a range of bytes to a SHA1 hash.  This routine is equivalent to, but faster than, calling [[sha1AddByte]] many times."}}, "Color": {"setLegacyLcdMode": {"sections": {"Notes": "Legacy mode simulates a 96x64 monochrome screen with the help of [[fastCopy]]. Color graphics are not advised in legacy mode."}, "name": "setLegacyLcdMode", "description": "Sets the LCD to legacy mode."}, "readLcdRegister": {"sections": {"Inputs": {"A": "Register"}, "Comments": "Destroys C", "Outputs": {"HL": "Value"}}, "name": "readLcdRegister", "description": "Reads a 16-bit value from a color LCD register"}, "clipColorRectangle": {"sections": {"Inputs": {"IY": "color of the rectangle in R5G6B5 format", "C": "height of the rectangle in pixels", "B": "Y coordinate in pixels", "DE": "width of the rectangle in pixels", "HL": "X coordinate in pixels"}, "Notes": "The rectangle will be clipped to any LCD window already in place, and restore it afterwards."}, "name": "clipColorRectangle", "description": "Draws a clipped rectangle of the specified size with the specified color in color mode."}, "writeLcdRegister": {"sections": {"Inputs": {"A": "Register", "HL": "Value"}, "Comments": "Destroys C"}, "name": "writeLcdRegister", "description": "Writes a 16-bit value to a color LCD register"}, "resetLegacyLcdMode": {"sections": {}, "name": "resetLegacyLcdMode", "description": "Sets the LCD to color mode. Call this before you call [[getLcdLock]]."}, "colorSupported": {"sections": {"Outputs": {"A": "errUnsupported if color is unsupported", "Z": "Set if supported, reset if unsupported"}}, "name": "colorSupported", "description": "Sets Z if color is supported on this device."}, "setLcdWindow": {"sections": {"Inputs": {"B": "top border", "DE": "right border", "C": "bottom border ", "HL": "left border"}, "Notes": "Destroys C"}, "name": "setLcdWindow", "description": "Sets the LCD's clipping window. Values are inclusive."}, "colorLcdOff": {"sections": {}, "name": "colorLcdOff", "description": "Turns off the color LCD and backlight."}, "fullScreenWindow": {"sections": {}, "name": "fullScreenWindow", "description": "Sets the clipping window to fit the LCD screen in color mode."}, "clearColorLcd": {"sections": {"Inputs": {"IY": "Color in 0bRRRRRGGGGGGBBBBB format"}, "Notes": "Overwrites the current clipping window."}, "name": "clearColorLcd", "description": "Sets all pixels on the LCD to a specified color in color mode."}, "checkLegacyLcdMode": {"sections": {}, "name": "checkLegacyLcdMode", "description": "Sets Z if the current thread is in legacy mode."}, "colorLcdOn": {"sections": {}, "name": "colorLcdOn", "description": "Initializes and turns on the color LCD in color mode."}}, "Text": {"drawStrXOR": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrXOR", "description": "Draws a zero-delimited string to the screen buffer using XOR logic (inverts pixels)."}, "drawHexA": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "A": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexA", "description": "Draws the contents of A in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "drawCharXOR": {"sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharXOR", "description": "Draws a character to the screen buffer using XOR logic (inverts pixels)."}, "drawStrAND": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrAND", "description": "Draws a zero-delimited string to the screen buffer using AND logic (turns pixels OFF)."}, "drawChar": {"sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawChar", "description": "Draws a character to the screen buffer using OR logic (turns pixels ON)."}, "newline": {"sections": {"Inputs": {"D, E": "X, Y", "B": "Left margin"}, "Notes": "This is identical to (but faster than) calling drawChar with '\\n'", "Outputs": {"D, E": "Moved down one line and to the left margin"}}, "name": "newline", "description": "Advances D, E to the next line of text"}, "drawHexHL": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "HL": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexHL", "description": "Draws the contents of HL in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "measureChar": {"sections": {"Inputs": {"A": "Character to measure"}, "Notes": "The height of each character is always 5 pixels. The width also often includes a column of empty pixels on the right (exceptions include '_').", "Outputs": {"A": "Width of character"}}, "name": "measureChar", "description": "Measures the width of a character in pixels."}, "drawStr": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStr", "description": "Draws a zero-delimited string to the screen buffer using OR logic (turns pixels ON)."}, "measureStr": {"sections": {"Inputs": {"HL": "String to measure"}, "Notes": "The height of any string is always 5 pixels. This function does not support newlines.", "Outputs": {"A": "Width of string"}}, "name": "measureStr", "description": "Measures the width of a string in pixels."}, "drawCharAND": {"sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharAND", "description": "Draws a character to the screen buffer using AND logic (turns pixels OFF)."}}, "Flash": {"writeFlashByte": {"sections": {"Inputs": {"A": "Value", "HL": "Destination"}, "Notes": "Flash must be unlocked. This can only *reset* bits of Flash."}, "name": "writeFlashByte", "description": "Writes a single byte to Flash."}, "lockFlash": {"sections": {}, "name": "lockFlash", "description": "Locks Flash and locks protected ports."}, "copySectorToSwap": {"sections": {"Inputs": {"A": "Any page within the sector to be copied"}, "Notes": "Flash must be unlocked."}, "name": "copySectorToSwap", "description": "Copies a single sector of Flash to the swap sector."}, "copyFlashPage": {"sections": {"Inputs": {"A": "Destination page", "B": "Source page"}, "Notes": "Flash must be unlocked and the desination page must be cleared."}, "name": "copyFlashPage", "description": "Copies one page of Flash to another."}, "unlockFlash": {"sections": {"Notes": "**Do not use this unless you know what you're doing.** Please call [[lockFlash]] when you finish what you're doing and don't spend too much time with Flash unlocked. Disable interrupts while Flash is unlocked."}, "name": "unlockFlash", "description": "Unlocks Flash and unlocks protected ports."}, "writeFlashBuffer": {"sections": {"Inputs": {"DE": "Address to write to", "HL": "Address to read from (in RAM)", "BC": "Length of data to write"}, "Notes": "Flash must be unlocked. Do not attempt to read your source data from Flash, you must load any data to be written into RAM. This will only *reset* bits of Flash."}, "name": "writeFlashBuffer", "description": "Writes several bytes of memory to Flash"}, "eraseSwapSector": {"sections": {"Notes": "Flash must be unlocked."}, "name": "eraseSwapSector", "description": "Erases the swap sector."}, "eraseFlashSector": {"sections": {"Inputs": {"A": "Any page within the target sector"}, "Notes": "Flash must be unlocked."}, "name": "eraseFlashSector", "description": "Erases one sector of Flash (generally 4 pages of Flash, or 64K) by setting each byte to 0xFF."}, "eraseFlashPage": {"sections": {"Inputs": {"A": "Target page"}, "Notes": "Flash must be unlocked. This is a very costly operation, and you may want to consider handling this logic yourself if you have to erase more than one page in a single sector"}, "name": "eraseFlashPage", "description": "Erases a single page of Flash."}}, "System": {"malloc": {"sections": {"Inputs": {"BC": "Length of requested section, in bytes"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "malloc", "description": "Allocates the specified amount of memory."}, "shutdown": {"sections": {}, "name": "shutdown", "description": "Shuts off the device."}, "memSeekToEnd": {"sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to last byte of section"}}, "name": "memSeekToEnd", "description": "Move IX to the end of the memory section it points to."}, "formatMem": {"sections": {"Notes": "This function will deallocate **all allocated memory**."}, "name": "formatMem", "description": "Formats memory in preparation for memory allocation."}, "memset": {"sections": {"Inputs": {"A": "Value to set", "IX": "Pointer to anywhere in allocated section"}}, "name": "memset", "description": "Sets the value of an entire allocated section of memory."}, "reboot": {"sections": {}, "name": "reboot", "description": "Restarts the device."}, "free": {"sections": {"Inputs": {"IX": "Pointer to first byte of section"}}, "name": "free", "description": "Frees a previously allocated section of memory"}, "reassignMemory": {"sections": {"Inputs": {"A": "Thread ID for new owner", "IX": "Pointer to any location within the target block."}}, "name": "reassignMemory", "description": "Reassigns a given block of memory to the specified thread ID."}, "loadLibrary": {"sections": {"Inputs": {"Z": "Set on success, reset on failure", "DE": "Pointer to full path of library"}}, "name": "loadLibrary", "description": "Loads a library into memory, or references one that may already be loaded."}, "calloc": {"sections": {"Inputs": {"A": "Size of element", "BC": "Number of elements"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated and zeroed memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "calloc", "description": "Allocates memory for a given number of elements of a given size (that is, BC * A bytes total), then fills it with zeros."}, "contextSwitch": {"sections": {}, "name": "contextSwitch", "description": "Triggers a context switch early. This will transfer control from your thread to another and eventaully return to yours with interrupts enabled."}, "memSeekToStart": {"sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to first byte of section"}}, "name": "memSeekToStart", "description": "Move IX to the beginning of the memory section it points to."}, "suspendDevice": {"sections": {}, "name": "suspendDevice", "description": "Turns off the screen, enters low power mode, and halts system operation until the ON key is pressed."}}, "Miscellaneous": {"rleCompress": {"sections": {"Inputs": {"DE": "Destination, cannot (yet) be the same location as original data", "HL": "Data to compress", "BC": "Size of uncompressed data"}, "Outputs": {"BC": "Size of compressed data", "AF": "Destroyed"}}, "name": "rleCompress", "description": "Compresses data using a simple Run-Length-Encoding scheme. All bytes in a compressed block are treated as literal, except the two following a sentinel byte (selected because of its low occurance in z80 code), which specify the length of the run and the byte to run with, respectively."}, "indirect16HLDE": {"sections": {"Notes": "This routine is useful as part of a callback for the callbackSort routine."}, "name": "indirect16HLDE", "description": "Performs HL = (HL) and DE = (DE)."}, "rleCalculateCompressedLength": {"sections": {"Inputs": {"HL": "Data to compress", "BC": "Size of decompressed data"}, "Outputs": {"BC": "Size of compressed data", "AF": "Destroyed"}}, "name": "rleCalculateCompressedLength", "description": "Calculates the size of data resulting from a compression, but does not actually compress anything."}, "randA": {"sections": {"Inputs": {"A'": "seed"}, "Outputs": {"A": "random byte", "A'": "reseeded"}}, "name": "randA", "description": "Returns a random byte in A."}, "compareStrings": {"sections": {"Inputs": {"DE": "String pointer", "HL": "String pointer"}, "Outputs": {"C": "Set if string HL is alphabetically earlier than string DE", "Z": "Set if equal, reset if not equal"}}, "name": "compareStrings", "description": "Determines if two strings are equal, and checks alphabetical sort order."}, "rleCalculateDecompressedLength": {"sections": {"Inputs": {"HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Destroyed"}}, "name": "rleCalculateDecompressedLength", "description": "Calculates the size of data resulting from a decompression, but does not actually decompress anything."}, "compareStrings_sort": {"sections": {"Inputs": {"DE": "Pointer to string pointer", "HL": "Pointer to string pointer"}, "Notes": "This routine is extremely useful as the callback for the [[callbackSort]] routine. It allows sorting a list of pointers to strings by the strings' sort order.", "Outputs": {"C": "Set if string (HL) is alphabetically earlier than string (DE)", "Z": "Set if equal, reset if not equal"}}, "name": "compareStrings_sort", "description": "Compares strings at ((HL)) and ((DE)).  That is, calls indirect16HLDE, then calls compareStrings."}, "hexToA": {"sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"A": "Value"}}, "name": "hexToA", "description": "Converts a hexadecimal string to a number."}, "callbackSort": {"sections": {"Inputs": {"IX": "Pointer to comparison function.", "DE": "Last element in array", "HL": "First element in array", "BC": "Size of element in bytes"}, "Notes": "The comparison function must affect the carry flag like cp (hl), (de) would.  (That is, set the carry flag if (HL) < (DE).)  All other registers must be preserved.  The algorithm (quicksort) uses an average of O(log n) stack space, with 8 bytes stack per recursion required.  Quicksort is in-place and is not a stable sort."}, "name": "callbackSort", "description": "Sorts an array of arbitrarily-sized blocks using a callback function to perform comparisons."}, "divACByDE": {"sections": {"Outputs": {"As described above, and": "", "HL": "Remainder"}}, "name": "divACByDE", "description": "Performs `AC = AC / DE`"}, "hexToHL": {"sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"HL": "Value"}}, "name": "hexToHL", "description": "Converts a hexadecimal string to a number."}, "indirect16HL": {"sections": {}, "name": "indirect16HL", "description": "Performs HL = (HL)"}, "getBatteryLevel": {"sections": {"Outputs": {"B": "Battery level"}, "Notes": "For 15MHz CPUs, B is a value from 0 to 4, where 0 is critical and 4 is full. For 6MHz CPUs, B is either 0 or 1, where 0 is critical and 1 is good."}, "name": "getBatteryLevel", "description": "Determines the approximate battery level."}, "integerSort": {"sections": {"Inputs": {"DE": "Last element in array", "HL": "first element in array"}, "Notes": "This routine is an in-place version of a radix sort, which has an O(k*n) runtime for k-bit numbers.  It also requires a smaller, fixed amount of stack space."}, "name": "integerSort", "description": "Sorts a specified array of 8-bit numbers using a fast (time complexity O(n)) algorithm."}, "stringLength": {"sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"BC": "String length"}}, "name": "stringLength", "description": "Determines the length of a zero delimited string."}, "stringCopy": {"sections": {"Inputs": {"DE": "Destination", "HL": "String pointer"}}, "name": "stringCopy", "description": "Copies a string."}, "cpHLDE_sort": {"sections": {"Inputs": {"DE": "Pointer to integer", "HL": "Pointer to integer"}, "Outputs": {"Same as z80 CP instruction.\n;; Notes": "", "This routine is extremely useful as the callback for the [[callbackSort]] routine.\n;;  It allows sorting a list of 16-bit numbers.\ncpHLDE_sort": ""}}, "name": "cpHLDE_sort", "description": "Compares 16-bit integers at (HL) and (DE).  That is, calls indirect16HLDE, then calls cpHLDE."}, "getBootCodeVersionString": {"sections": {"Outputs": {"HL": "String pointer"}, "Notes": "This allocates memory to hold the string. Deallocate it with [[free]] when you no longer need it."}, "name": "getBootCodeVersionString", "description": "Gets the version string from the device's boot code."}, "rleDecompress": {"sections": {"Inputs": {"DE": "Destination, cannot be the same location as original data", "HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Destroyed"}}, "name": "rleDecompress", "description": "Decompresses data compressed with the algorithm used by the kernel routine rleCompress.  See its documentation for algorithm details."}}, "Hardware": {"getIOLock": {"sections": {}, "name": "getIOLock", "description": "Locks the I/O port to the current thread."}, "getKeypadLock": {"sections": {}, "name": "getKeypadLock", "description": "Locks the keyboard to the current thread."}, "hasIOLock": {"sections": {}, "name": "hasIOLock", "description": "Sets Z if the current thread has a lock on the I/O port."}, "hasLCDLock": {"sections": {}, "name": "hasLCDLock", "description": "Sets Z if the current thread has a lock on the LCD."}, "hasKeypadLock": {"sections": {}, "name": "hasKeypadLock", "description": "Sets Z if the current thread has a lock on the keyboard."}, "getUSBLock": {"sections": {}, "name": "getUSBLock", "description": "Locks the USB port to the current thread."}, "getLcdLock": {"sections": {}, "name": "getLcdLock", "description": "Locks the LCD to the current thread."}, "hasUSBLock": {"sections": {}, "name": "hasUSBLock", "description": "Sets Z if the current thread has a lock on the USB."}}, "Threading": {"launchProgram": {"sections": {"Inputs": {"DE": "Path to executable file"}, "Outputs": {"A": "Thread ID (on success), error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "launchProgram", "description": "Loads the specified file into memory as a program and starts a new thread for it."}, "setInitialHL": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of HL"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialHL", "description": "Sets the initial value of the HL register for the specified thread."}, "setReturnPoint": {"sections": {"Inputs": {"A": "Thread ID", "HL": "Return point"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setReturnPoint", "description": "Sets the return point for the specified thread. This is set to [[killThread]] by default."}, "setInitialDE": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of DE"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialDE", "description": "Sets the initial value of the DE register for the specified thread."}, "killCurrentThread": {"sections": {"Notes": "In most cases, it is preferrable to call [[exitThread]], which will use the exit function specified by the caller. This function cleans up all resources owned by that thread, including allocated memory, loaded libraries, file handles, etc."}, "name": "killCurrentThread", "description": "Kills the currently executing thread."}, "suspendCurrentThread": {"sections": {"Notes": "This function will not return until a second thread resumes the current thread."}, "name": "suspendCurrentThread", "description": "Suspends the currently executing thread."}, "setInitialA": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "H": "Initial value of A"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialA", "description": "Sets the initial value of the A register for the specified thread."}, "setInitialBC": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of BC"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialBC", "description": "Sets the initial value of the BC register for the specified thread."}, "killThread": {"sections": {"Inputs": {"A": "Thread ID"}, "Notes": "This function cleans up all resources owned by that thread, including allocated memory, loaded libraries, file handles, etc.", "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "killThread", "description": "Kills the specified thread."}, "setInitialIY": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IY"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIY", "description": "Sets the initial value of the IY register for the specified thread."}, "setInitialIX": {"sections": {"Note": "Do **not** call this function on a thread that has already been started. You must have interrupts disabled when you call [[startThread]], and leave them disabled until after you have finished setting the initial state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IX"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIX", "description": "Sets the initial value of the IX register for the specified thread."}, "getThreadEntry": {"sections": {"Inputs": {"A": "Thread ID"}, "Notes": "You must disable interrupts while manipulating the thread table to guarantee that it will not change while you do so. Programs that manipulate the thread table directly should force a specific major kernel version, as this is liable to change between versions.", "Outputs": {"HL": "Thread entry"}}, "name": "getThreadEntry", "description": "Gets a pointer to the specified thread's entry in the thread table."}, "startThread": {"sections": {"Inputs": {"A": "Thread flags", "B": "Desired stack size / 2", "HL": "Pointer to thread executable"}, "Notes": "If you wish to manipulate this thread before it executes (to set the initial value of the registers, for instance), disable interrupts before calling startThread, and re-enable them when you're ready to start the thread. If you want to postpone starting the thread for an extended period of time, call [[suspendThread]] before re-enabling interrupts, and [[resumeThread]] when you're ready to start it.", "Outputs": {"A": "ID of new thread (on success); Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "startThread", "description": "Starts a new thread."}, "readSignal": {"sections": {"Outputs": {"B": "Message type", "Z": "Set if a signal was read, reset if there are no pending signals", "HL": "Message payload"}}, "name": "readSignal", "description": "Reads the next pending signal from this thread's signal queue."}, "exitThread": {"sections": {"Notes": "This is preferred to [[killCurrentThread]], since it will go through the caller-set exit function. This is often [[killCurrentThread]] anyway, but it may be set to a custom value by the code that intitialized the thread."}, "name": "exitThread", "description": "Immediately terminates the running thread."}, "createSignal": {"sections": {"Inputs": {"A": "Target thread ID", "B": "Message type", "HL": "Message payload"}, "Notes": "The receiving thread may use [[readSignal]] to consume this message."}, "name": "createSignal", "description": "Signals another thread with a simple message."}, "getCurrentThreadID": {"sections": {"Outputs": {"A": "Thread ID"}}, "name": "getCurrentThreadID", "description": "Gets the ID of the currently executing thread."}, "resumeThread": {"sections": {"Inputs": {"A": "Thread ID"}}, "name": "resumeThread", "description": "Resumes the specified thread."}}, "Filesystem": {"fileExists": {"sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "fileExists", "description": "Determines if a file exists."}, "formatUnusedPages": {"sections": {"Notes": "This function is only relevant to system-level programmers. Most programmers do not have to concern themselves with it."}, "name": "formatUnusedPages", "description": "If /bin/init is called with A set to 0xFF, this function should be called. It may be appropriate to show the user some sort of UI while this is processing, as it will take some time to run."}, "findDirectoryEntry": {"sections": {"Inputs": {"DE": "Path to directory"}, "Notes": "This function returns HL=0 for the root directory. You should handle this special case yourself. The root directory has ID 0 and has no parent directory.", "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "findDirectoryEntry", "description": "Finds a directory entry in the FAT."}, "createDirectoryEntry": {"sections": {"Inputs": {"DE": "Parent ID", "HL": "Directory name"}, "Outputs": {"A": "New entry Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "New entry address relative to 0x4000 (on success)"}}, "name": "createDirectoryEntry", "description": "Creates a new directory entry in the FAT."}, "findFileEntry": {"sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "findFileEntry", "description": "Finds a file entry in the FAT."}, "directoryExists": {"sections": {"Inputs": {"DE": "Path to directory (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "directoryExists", "description": "Determines if a directory exists."}, "createFileEntry": {"sections": {"Inputs": {"IY": "Section ID", "DE": "Parent ID", "ABC": "Length", "HL": "File name"}, "Outputs": {"A": "New entry Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "New entry address relative to 0x4000 (on success)"}}, "name": "createFileEntry", "description": "Creates a new file entry in the FAT."}, "listDirectory": {"sections": {"Inputs": {"DE": "Path to directory", "HL": "Callback"}, "Notes": "This function will call your callback every time it encounters a relevant entry on the filesystem. You are free to use IX, IY, and the shadow registers in this callback, but must preserve all other registers. Your function will be called with the following state: * HL: Address of entry * BC: Length of entry * A: Type of entry * kernelGarbage: Name of entry * Correct page swapped into bank A * Interrupts disabled (do not enable them) You must leave these registers intact.", "Outputs": {"A": "Error code on failure, preserved on success", "Z": "Set on success, reset on failure"}}, "name": "listDirectory", "description": "Lists the contents of a directory on the filesystem."}, "createDirectory": {"sections": {"Inputs": {"DE": "Path to new directory"}, "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "createDirectory", "description": "Creates a new directory in the filesystem and returns information about the new filesystem entry."}, "deleteFile": {"sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set if file was deleted, reset if file did not exist"}}, "name": "deleteFile", "description": "Deletes a file."}}, "Maths": {"sdivACbyDE": {"sections": {"Outputs": {"As described above, and\n;;  HL": "remainder"}, "Notes": "B is destroyed"}, "name": "sdivACbyDE", "description": "Performs `AC = AC / DE`. The operation is signed."}, "cpHLDE": {"sections": {"Output": "Same as z80 CP instruction."}, "name": "cpHLDE", "description": "Compares HL to DE."}, "sDEMulA": {"sections": {"Performs `HL = DE * A`. The operation is signed.\nsDEMulA": ""}, "name": "sDEMulA", "description": ""}, "cpBCDE": {"sections": {"Output": "Same as z80 CP instruction."}, "name": "cpBCDE", "description": "Compares DE to BC."}, "smax": {"sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the smallest of the previous HL and DE", "HL": "the largest of the previous HL and DE"}}, "name": "smax", "description": "Returns the largest between HL and DE. The operation is signed."}, "cpHLBC": {"sections": {"Output": "Same as z80 CP instruction."}, "name": "cpHLBC", "description": "Compares HL to BC."}, "DEMulBC": {"sections": {}, "name": "DEMulBC", "description": "Performs `HL = DE * BC`"}, "divHLByC": {"sections": {"Outputs": {"A": "Remainder", "As described above, and": ""}}, "name": "divHLByC", "description": "Performs `HL = HL / C`"}, "sub16From32": {"sections": {}, "name": "sub16From32", "description": "Performs `ACIX = ACIX - DE`"}, "add16To32": {"sections": {}, "name": "add16To32", "description": "Performs `ACIX = ACIX + DE`"}, "isin": {"sections": {"Inputs": {"A": "angle"}, "Notes": "To fit assembly, both the input and output have an uncommon format : the input angle has a period of 256, and the outputted value will be in the range [-64, 64] instead of [-1,1].", "Outputs": {"A": "sine of the angle, scaled to 64"}}, "name": "isin", "description": "Returns the sine of the given angle."}, "div32By16": {"sections": {"Outputs": {"As described above, and": "", "B": "0", "HL": "Remainder"}}, "name": "div32By16", "description": "Performs `ACIX = ACIX / DE`"}, "icos": {"sections": {"Inputs": {"A": "angle"}, "Notes": "To fit assembly, both the input and output have an uncommon format : the input angle has a period of 256, and the outputted value will be in the range [-63, 63] instead of [-1,1].", "Outputs": {"A": "sine of the angle, scaled to 64"}}, "name": "icos", "description": "Returns the cosine of the given angle."}, "DEMulA": {"sections": {}, "name": "DEMulA", "description": "Performs `HL = DE * A`"}, "smin": {"sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the largest of the previous HL and DE", "HL": "the smallest of the previous HL and DE"}}, "name": "smin", "description": "Returns the smallest between HL and DE. The operation is signed."}}, "Input": {"flushKeys": {"sections": {}, "name": "flushKeys", "description": "Blocks until all keys are released."}, "getKey": {"sections": {"Outputs": {"A": "Key code"}}, "name": "getKey", "description": "Returns the currently pressed key code, or zero if no keys are pressed."}, "waitKey": {"sections": {"Outputs": {"A": "Key code"}}, "name": "waitKey", "description": "Blocks until a key is pressed, then returns that key code."}}, "Display": {"rectAND": {"sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectAND", "description": "Draws a filled rectangle on the screen buffer using AND (turns pixels OFF) logic."}, "putSpriteXOR": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteXOR", "description": "Draws an 8xB sprite on the screen buffer using XOR (invert) logic."}, "drawLine": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X1, Y1", "H, L": "X2, Y2"}, "Notes": "This function does not clip lines to the screen boundaries."}, "name": "drawLine", "description": "Draws a line on the screen buffer using OR (turns pixels ON) logic."}, "getPixel": {"sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}, "Notes": "If the pixel is on, HL & A is nonzero.", "Outputs": {"A": "Mask", "HL": "Address of pixel"}}, "name": "getPixel", "description": "Finds the address of and mask for a pixel on the screen buffer."}, "rectOR": {"sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectOR", "description": "Draws a filled rectangle on the screen buffer using OR (turns pixels ON) logic."}, "putSprite16OR": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16OR", "description": "Draws a 16xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "putSpriteOR": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteOR", "description": "Draws an 8xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "putSprite16AND": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16AND", "description": "Draws a 16xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "resetPixel": {"sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "resetPixel", "description": "Sets (turns on) a pixel on the screen buffer."}, "setPixel": {"sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "setPixel", "description": "Sets (turns on) a pixel on the screen buffer."}, "rectXOR": {"sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectXOR", "description": "Draws a filled rectangle on the screen buffer using XOR (invert) logic."}, "putSpriteAND": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteAND", "description": "Draws an 8xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "invertPixel": {"sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "invertPixel", "description": "Inverts a pixel on the screen buffer."}, "fastCopy": {"sections": {"Inputs": {"IY": "Screen buffer"}, "Notes": "This routine will return immediately without drawing to the LCD if the calling thead does not have an LCD lock. Acquire one with [[getLcdLock]]. On a TI-84+ CSE, this routine will draw the 96x64 monochrome buffer (the \"legacy\" buffer) to the LCD. The LCD should be set to legacy mode (see [[setLegacyLcdMode]])."}, "name": "fastCopy", "description": "Copies the screen buffer to the LCD."}, "clearBuffer": {"sections": {"Inputs": {"IY": "Screen buffer"}}, "name": "clearBuffer", "description": "Turns off all pixels on a screen buffer."}, "allocScreenBuffer": {"sections": {"Outputs": {"IY": "Screen buffer"}}, "name": "allocScreenBuffer", "description": "Allocates a 768-byte screen buffer."}, "putSprite16XOR": {"sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16XOR", "description": "Draws a 16xB sprite on the screen buffer using XOR (invert) logic."}}, "Filestreams": {"getStreamBuffer": {"sections": {"Inputs": {"D": "Stream ID"}, "Notes": "For read-only streams, modifying this buffer could have unforseen consequences and it will not be copied back to the file. For writable streams, make sure you call flush if you modify this buffer and want to make the changes persist to the file.", "Outputs": {"A": "Error code (on failure)", "IX": "Stream buffer (on success)", "Z": "Set on success, reset on failure"}}, "name": "getStreamBuffer", "description": "Gets the address of a stream's memory buffer."}, "getStreamEntry": {"sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "IX": "File stream entry poitner (on success)", "Z": "Set on success, reset on failure"}}, "name": "getStreamEntry", "description": "Gets the address of a stream entry in the kernel file stream table."}, "streamReadBuffer": {"sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID", "BC": "Length"}, "Notes": "If BC is greater than the remaining space in the stream, the stream will be advanced to the end before returning an error.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadBuffer", "description": "Reads a number of bytes from a file stream and advances the stream."}, "openFileWrite": {"sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileWrite", "description": "Opens a file stream in write mode. If the file does not exist, it is created."}, "closeStream": {"sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "closeStream", "description": "Closes an open stream."}, "streamReadByte": {"sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Data read (on success); Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadByte", "description": "Reads a single byte from a file stream and advances the stream."}, "openFileRead": {"sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileRead", "description": "Opens a file stream in read-only mode."}, "flush": {"sections": {"Inputs": {"D": "Stream ID"}, "Notes": "This happens periodically as you write to the stream, and happens automatically on closeStream. Try not to use it unless you have to.", "Outputs": {"A": "Preserved on success; error code on error", "Z": "Set on success, reset on error"}}, "name": "flush", "description": "Flushes pending writes to disk."}, "streamReadToEnd": {"sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadToEnd", "description": "Reads the remainder of a file stream into memory."}, "streamReadWord": {"sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Data read (on success)"}}, "name": "streamReadWord", "description": "Reads a 16-bit word from a file stream and advances the stream."}, "getStreamInfo": {"sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "EBC": "Remaining space in stream (on success)"}}, "name": "getStreamInfo", "description": "Gets the amount of space remaining in a file stream."}}}