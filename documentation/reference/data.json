{"Time": {"convertTimeFromTicks": {"path": "kernel/src/02/time.asm", "line": 67, "sections": {"Inputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}, "Outputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "E": "Garbage", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}}, "name": "convertTimeFromTicks", "description": "Convert from ticks in seconds to time. The epoch is January 1st, 1997 (a Wednesday)"}, "getTime": {"path": "kernel/src/02/time.asm", "line": 282, "sections": {"Outputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "E": "Garbage", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}}, "name": "getTime", "description": "Gets the current time."}, "setClock": {"path": "kernel/src/02/time.asm", "line": 1, "sections": {"Inputs": {"DE": "Upper word of a 32-bit tick value", "HL": "Lower word of a 32-bit tick value"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure"}}, "name": "setClock", "description": "Sets the internal clock."}, "convertTimeToTicks": {"path": "kernel/src/02/time.asm", "line": 265, "sections": {"Inputs": {"A": "Day of the week, from 0-6 with 0 being sunday", "IX": "Current year", "C": "Current minute, from 0-59", "B": "Current hour, from 0-23", "D": "Current second, from 0-59", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}, "Outputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}}, "name": "convertTimeToTicks", "description": "Converts a time structure to seconds since epoch."}, "getClock": {"path": "kernel/src/02/time.asm", "line": 33, "sections": {"Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure", "DE": "Upper word of the 32-bit tick value", "HL": "Lower word of the 32-bit tick value"}}, "name": "getClock", "description": "Gets the internal clock."}}, "Cryptography": {"sha1Clean": {"path": "kernel/src/02/crypto.asm", "line": 109, "sections": {"Inputs": {"IX": "location of allocated block"}}, "name": "sha1Clean", "description": "Safely deallocates a SHA1 state block allocated by sha1Init."}, "crc16": {"path": "kernel/src/02/crypto.asm", "line": 1, "sections": {"Inputs": {"HL": "Pointer to data", "BC": "Size of data"}, "Outputs": {"DE": "CRC of data"}}, "name": "crc16", "description": "Performs a Cyclic Redundancy Check on data."}, "sha1Init": {"path": "kernel/src/02/crypto.asm", "line": 36, "sections": {"Outputs": {"A": "Error code (on failure)", "IX": "location of allocated block (on success)", "Z": "Set on success, reset on failure"}}, "name": "sha1Init", "description": "Allocates a memory block to keep the state and result of a SHA1 hash operation.  The result is kept in the first 20 bytes of the allocated block.  You must use [[sha1Clean]] to deallocate the block; simply using [[free]] will result in a memory leak!"}, "sha1AddByte": {"path": "kernel/src/02/crypto.asm", "line": 163, "sections": {"Inputs": {"A": "Byte to add", "IX": "location of SHA1 state block"}}, "name": "sha1AddByte", "description": "Adds a single byte to the SHA1 hash input stream. Call this function once for each byte in the input stream, then call [[sha1Pad]]."}, "sha1Pad": {"path": "kernel/src/02/crypto.asm", "line": 126, "sections": {"Inputs": {"IX": "location of SHA1 state block"}}, "name": "sha1Pad", "description": "Finishes the SHA1 computation by appending the required bits to the input.  Call this routine once after calling [[sha1AddByte]] for each input byte.  After this routine, the 8 bytes pointed to by IX will contain the big-endian SHA1 hash."}, "sha1AddRange": {"path": "kernel/src/02/crypto.asm", "line": 454, "sections": {"Inputs": {"IX": "location of SHA1 state block", "HL": "location of range to add", "BC": "number of bytes to add"}}, "name": "sha1AddRange", "description": "Adds a range of bytes to a SHA1 hash.  This routine is equivalent to, but faster than, calling [[sha1AddByte]] many times."}}, "Color": {"setLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 397, "sections": {"Notes": "\n Legacy mode simulates a 96x64 monochrome screen with the help of [[fastCopy]]. Color \n graphics are not advised in legacy mode."}, "name": "setLegacyLcdMode", "description": "Sets the LCD to legacy mode."}, "readLcdRegister": {"path": "kernel/src/00/display-color.asm", "line": 105, "sections": {"Inputs": {"A": "Register"}, "Comments": "\n Destroys C", "Outputs": {"HL": "Value"}}, "name": "readLcdRegister", "description": "Reads a 16-bit value from a color LCD register"}, "clipColorRectangle": {"path": "kernel/src/00/display-color.asm", "line": 567, "sections": {"Inputs": {"IY": "color of the rectangle in R5G6B5 format", "C": "height of the rectangle in pixels", "B": "Y coordinate in pixels", "DE": "width of the rectangle in pixels", "HL": "X coordinate in pixels"}, "Notes": "\n The rectangle will be clipped to any LCD window already in \n place, and restore it afterwards."}, "name": "clipColorRectangle", "description": "Draws a clipped rectangle of the specified size with the specified color in color mode."}, "writeLcdRegister": {"path": "kernel/src/00/display-color.asm", "line": 41, "sections": {"Inputs": {"A": "Register", "HL": "Value"}, "Comments": "\n Destroys C"}, "name": "writeLcdRegister", "description": "Writes a 16-bit value to a color LCD register"}, "resetLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 479, "sections": {}, "name": "resetLegacyLcdMode", "description": "Sets the LCD to color mode. Call this before you call [[getLcdLock]]."}, "colorSupported": {"path": "kernel/src/00/display-color.asm", "line": 32, "sections": {"Outputs": {"A": "errUnsupported if color is unsupported", "Z": "Set if supported, reset if unsupported"}}, "name": "colorSupported", "description": "Sets Z if color is supported on this device."}, "setLcdWindow": {"path": "kernel/src/00/display-color.asm", "line": 55, "sections": {"Inputs": {"B": "top border", "DE": "right border", "C": "bottom border ", "HL": "left border"}, "Notes": "\n Destroys C"}, "name": "setLcdWindow", "description": "Sets the LCD's clipping window. Values are inclusive."}, "colorLcdOff": {"path": "kernel/src/00/display-color.asm", "line": 199, "sections": {}, "name": "colorLcdOff", "description": "Turns off the color LCD and backlight."}, "fullScreenWindow": {"path": "kernel/src/00/display-color.asm", "line": 91, "sections": {}, "name": "fullScreenWindow", "description": "Sets the clipping window to fit the LCD screen in color mode."}, "clearColorLcd": {"path": "kernel/src/00/display-color.asm", "line": 318, "sections": {"Inputs": {"IY": "Color in 0bRRRRRGGGGGGBBBBB format"}, "Notes": "\n Overwrites the current clipping window."}, "name": "clearColorLcd", "description": "Sets all pixels on the LCD to a specified color in color mode."}, "checkLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 531, "sections": {}, "name": "checkLegacyLcdMode", "description": "Sets Z if the current thread is in legacy mode."}, "colorLcdOn": {"path": "kernel/src/00/display-color.asm", "line": 133, "sections": {}, "name": "colorLcdOn", "description": "Initializes and turns on the color LCD in color mode."}}, "Text": {"drawStrXOR": {"path": "kernel/src/01/text.asm", "line": 287, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrXOR", "description": "Draws a zero-delimited string to the screen buffer using XOR logic (inverts pixels)."}, "drawHexA": {"path": "kernel/src/01/text.asm", "line": 403, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "A": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexA", "description": "Draws the contents of A in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "drawDecA": {"path": "kernel/src/01/text.asm", "line": 431, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "A": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawDecA", "description": "Draws the contents of A in decimal to the screen buffer using OR logic (turns pixels ON)."}, "wrapStrAND": {"path": "kernel/src/01/text.asm", "line": 340, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStrAND", "description": "Draws a zero-delimited string to the screen buffer using AND logic (turns pixels OFF), and wraps it inside a rectangle, with character breaks."}, "drawCharXOR": {"path": "kernel/src/01/text.asm", "line": 78, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharXOR", "description": "Draws a character to the screen buffer using XOR logic (inverts pixels)."}, "measureStr": {"path": "kernel/src/01/text.asm", "line": 560, "sections": {"Inputs": {"HL": "String to measure"}, "Notes": "\n The height of any string is always 5 pixels. This function does not support newlines.", "Outputs": {"A": "Width of string"}}, "name": "measureStr", "description": "Measures the width of a string in pixels."}, "drawStrAND": {"path": "kernel/src/01/text.asm", "line": 269, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrAND", "description": "Draws a zero-delimited string to the screen buffer using AND logic (turns pixels OFF)."}, "drawChar": {"path": "kernel/src/01/text.asm", "line": 42, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawChar", "description": "Draws a character to the screen buffer using OR logic (turns pixels ON)."}, "newline": {"path": "kernel/src/01/text.asm", "line": 3, "sections": {"Inputs": {"D, E": "X, Y", "B": "Left margin"}, "Notes": "\n This is identical to (but faster than) calling drawChar with '\\n'", "Outputs": {"D, E": "Moved down one line and to the left margin"}}, "name": "newline", "description": "Advances D, E to the next line of text"}, "drawHexHL": {"path": "kernel/src/01/text.asm", "line": 504, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "HL": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexHL", "description": "Draws the contents of HL in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "measureChar": {"path": "kernel/src/01/text.asm", "line": 533, "sections": {"Inputs": {"A": "Character to measure"}, "Notes": "\n The height of each character is always 5 pixels. The width also often includes a column of empty pixels on the right (exceptions include '_').", "Outputs": {"A": "Width of character"}}, "name": "measureChar", "description": "Measures the width of a character in pixels."}, "drawStr": {"path": "kernel/src/01/text.asm", "line": 251, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStr", "description": "Draws a zero-delimited string to the screen buffer using OR logic (turns pixels ON)."}, "wrapStrXOR": {"path": "kernel/src/01/text.asm", "line": 362, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStrXOR", "description": "Draws a zero-delimited string to the screen buffer using XOR logic (inverts pixels), and wraps it inside a rectangle, with character breaks."}, "wrapStr": {"path": "kernel/src/01/text.asm", "line": 318, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStr", "description": "Draws a zero-delimited string to the screen buffer using OR logic (turns pixels ON), and wraps it inside a rectangle, with character breaks."}, "drawDecHL": {"path": "kernel/src/01/text.asm", "line": 521, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "HL": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawDecHL", "description": "Draws the contents of HL in decimal to the screen buffer using OR logic (turns pixels ON)."}, "drawCharAND": {"path": "kernel/src/01/text.asm", "line": 60, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharAND", "description": "Draws a character to the screen buffer using AND logic (turns pixels OFF)."}}, "Flash": {"writeFlashByte": {"path": "kernel/src/00/flash.asm", "line": 43, "sections": {"Inputs": {"A": "Value", "HL": "Destination"}, "Notes": "\n Flash must be unlocked. This can only *reset* bits of Flash."}, "name": "writeFlashByte", "description": "Writes a single byte to Flash."}, "copyFlashExcept": {"path": "kernel/src/00/flash.asm", "line": 471, "sections": {"Inputs": {"A": "Destination page", "B": "Source page"}, "Notes": "\n Flash must be unlocked and the destination page must be cleared."}, "name": "copyFlashExcept", "description": "Copies all but the first 0x200 bytes of Flash from one page to another."}, "lockFlash": {"path": "kernel/src/00/flash.asm", "line": 26, "sections": {}, "name": "lockFlash", "description": "Locks Flash and locks protected ports."}, "copySectorToSwap": {"path": "kernel/src/00/flash.asm", "line": 300, "sections": {"Inputs": {"A": "Any page within the sector to be copied"}, "Notes": "\n Flash must be unlocked."}, "name": "copySectorToSwap", "description": "Copies a single sector of Flash to the swap sector."}, "copyFlashPage": {"path": "kernel/src/00/flash.asm", "line": 622, "sections": {"Inputs": {"A": "Destination page", "B": "Source page"}, "Notes": "\n Flash must be unlocked and the desination page must be cleared."}, "name": "copyFlashPage", "description": "Copies one page of Flash to another."}, "unlockFlash": {"path": "kernel/src/00/flash.asm", "line": 4, "sections": {"Notes": "\n **Do not use this unless you know what you're doing.** \n \n Please call [[lockFlash]] when you finish what you're doing and don't spend too \n much time with Flash unlocked. Disable interrupts while Flash is unlocked."}, "name": "unlockFlash", "description": "Unlocks Flash and unlocks protected ports."}, "writeFlashBuffer": {"path": "kernel/src/00/flash.asm", "line": 113, "sections": {"Inputs": {"DE": "Address to write to", "HL": "Address to read from (in RAM)", "BC": "Length of data to write"}, "Notes": "\n Flash must be unlocked. Do not attempt to read your source data \n from Flash, you must load any data to be written into RAM. This \n will only *reset* bits of Flash."}, "name": "writeFlashBuffer", "description": "Writes several bytes of memory to Flash"}, "eraseSwapSector": {"path": "kernel/src/00/flash.asm", "line": 186, "sections": {"Notes": "\n Flash must be unlocked."}, "name": "eraseSwapSector", "description": "Erases the swap sector."}, "eraseFlashSector": {"path": "kernel/src/00/flash.asm", "line": 197, "sections": {"Inputs": {"A": "Any page within the target sector"}, "Notes": "\n Flash must be unlocked."}, "name": "eraseFlashSector", "description": "Erases one sector of Flash (generally 4 pages of Flash, or 64K) by setting each byte to 0xFF."}, "eraseFlashPage": {"path": "kernel/src/00/flash.asm", "line": 258, "sections": {"Inputs": {"A": "Target page"}, "Notes": "\n Flash must be unlocked. This is a very costly operation, and you \n may want to consider handling this logic yourself if you have to \n erase more than one page in a single sector"}, "name": "eraseFlashPage", "description": "Erases a single page of Flash."}}, "System": {"malloc": {"path": "kernel/src/00/memory.asm", "line": 163, "sections": {"Inputs": {"BC": "Length of requested section, in bytes"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "malloc", "description": "Allocates the specified amount of memory."}, "shutdown": {"path": "kernel/src/00/boot.asm", "line": 5, "sections": {}, "name": "shutdown", "description": "Shuts off the device."}, "memSeekToEnd": {"path": "kernel/src/00/memory.asm", "line": 144, "sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to last byte of section"}}, "name": "memSeekToEnd", "description": "Move IX to the end of the memory section it points to."}, "formatMem": {"path": "kernel/src/00/memory.asm", "line": 1, "sections": {"Notes": "\n This function will deallocate **all allocated memory**."}, "name": "formatMem", "description": "Formats memory in preparation for memory allocation."}, "memset": {"path": "kernel/src/00/memory.asm", "line": 88, "sections": {"Inputs": {"A": "Value to set", "IX": "Pointer to anywhere in allocated section"}}, "name": "memset", "description": "Sets the value of an entire allocated section of memory."}, "reboot": {"path": "kernel/src/00/boot.asm", "line": 43, "sections": {}, "name": "reboot", "description": "Restarts the device."}, "free": {"path": "kernel/src/00/memory.asm", "line": 326, "sections": {"Inputs": {"IX": "Pointer to first byte of section"}}, "name": "free", "description": "Frees a previously allocated section of memory"}, "reassignMemory": {"path": "kernel/src/00/memory.asm", "line": 39, "sections": {"Inputs": {"A": "Thread ID for new owner", "IX": "Pointer to any location within the target block."}}, "name": "reassignMemory", "description": "Reassigns a given block of memory to the specified thread ID."}, "loadLibrary": {"path": "kernel/src/00/libraries.asm", "line": 6, "sections": {"Inputs": {"Z": "Set on success, reset on failure", "DE": "Pointer to full path of library"}}, "name": "loadLibrary", "description": "Loads a library into memory, or references one that may already be loaded."}, "calloc": {"path": "kernel/src/00/memory.asm", "line": 52, "sections": {"Inputs": {"A": "Size of element", "BC": "Number of elements"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated and zeroed memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "calloc", "description": "Allocates memory for a given number of elements of a given size (that is, BC * A bytes total), then fills it with zeros."}, "contextSwitch": {"path": "kernel/src/00/interrupt.asm", "line": 1, "sections": {}, "name": "contextSwitch", "description": "Triggers a context switch early. This will transfer control from your thread to another and eventaully return to yours with interrupts enabled."}, "memSeekToStart": {"path": "kernel/src/00/memory.asm", "line": 111, "sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to first byte of section"}}, "name": "memSeekToStart", "description": "Move IX to the beginning of the memory section it points to."}, "suspendDevice": {"path": "kernel/src/00/util.asm", "line": 1, "sections": {}, "name": "suspendDevice", "description": "Turns off the screen, enters low power mode, and halts system operation until the ON key is pressed."}}, "Display": {"rectAND": {"path": "kernel/src/02/graphics.asm", "line": 276, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectAND", "description": "Draws a filled rectangle on the screen buffer using AND (turns pixels OFF) logic."}, "drawVLineAND": {"path": "kernel/src/02/graphics.asm", "line": 133, "sections": {"Inputs": {"IY": "screen buffer", "C": "height", "A, L": "X, Y"}}, "name": "drawVLineAND", "description": "Draws a vertical line on the screen buffer using AND (turns pixels OFF) logic. Does clipping."}, "putSpriteXOR": {"path": "kernel/src/00/display.asm", "line": 85, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteXOR", "description": "Draws an 8xB sprite on the screen buffer using XOR (invert) logic."}, "drawLine": {"path": "kernel/src/00/display.asm", "line": 868, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X1, Y1", "H, L": "X2, Y2"}, "Notes": "\n This function does not clip lines to the screen boundaries."}, "name": "drawLine", "description": "Draws a line on the screen buffer using OR (turns pixels ON) logic."}, "getPixel": {"path": "kernel/src/02/graphics.asm", "line": 1, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}, "Notes": "\n If the pixel is on, HL & A is nonzero.", "Outputs": {"A": "Mask", "HL": "Address of pixel"}}, "name": "getPixel", "description": "Finds the address of and mask for a pixel on the screen buffer."}, "rectOR": {"path": "kernel/src/00/display.asm", "line": 1138, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectOR", "description": "Draws a filled rectangle on the screen buffer using OR (turns pixels ON) logic."}, "putSprite16OR": {"path": "kernel/src/00/display.asm", "line": 678, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16OR", "description": "Draws a 16xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "putSpriteOR": {"path": "kernel/src/00/display.asm", "line": 417, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteOR", "description": "Draws an 8xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "putSprite16AND": {"path": "kernel/src/00/display.asm", "line": 771, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16AND", "description": "Draws a 16xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "resetPixel": {"path": "kernel/src/02/graphics.asm", "line": 68, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "resetPixel", "description": "Sets (turns on) a pixel on the screen buffer."}, "setPixel": {"path": "kernel/src/02/graphics.asm", "line": 53, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "setPixel", "description": "Sets (turns on) a pixel on the screen buffer."}, "rectXOR": {"path": "kernel/src/02/graphics.asm", "line": 168, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectXOR", "description": "Draws a filled rectangle on the screen buffer using XOR (invert) logic."}, "drawVLine": {"path": "kernel/src/02/graphics.asm", "line": 99, "sections": {"Inputs": {"IY": "screen buffer", "C": "height", "A, L": "X, Y"}}, "name": "drawVLine", "description": "Draws a vertical line on the screen buffer using OR (turns pixels ON) logic. Does clipping."}, "freeScreenBuffer": {"path": "kernel/src/00/memory.asm", "line": 28, "sections": {"Inputs": {"IY": "Screen buffer"}}, "name": "freeScreenBuffer", "description": "Deallocates a screen buffer allocated with [[allocScreenBuffer]]"}, "putSpriteAND": {"path": "kernel/src/00/display.asm", "line": 246, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteAND", "description": "Draws an 8xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "invertPixel": {"path": "kernel/src/02/graphics.asm", "line": 84, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "invertPixel", "description": "Inverts a pixel on the screen buffer."}, "fastCopy": {"path": "kernel/src/00/display.asm", "line": 22, "sections": {"Inputs": {"IY": "Screen buffer"}, "Notes": "\n This routine will return immediately without drawing to the LCD if the calling thead does not have an \n LCD lock. Acquire one with [[getLcdLock]]. \n \n On a TI-84+ CSE, this routine will draw the 96x64 monochrome buffer (the \"legacy\" buffer) to the LCD. \n The LCD should be set to legacy mode (see [[setLegacyLcdMode]])."}, "name": "fastCopy", "description": "Copies the screen buffer to the LCD."}, "clearBuffer": {"path": "kernel/src/00/display.asm", "line": 1, "sections": {"Inputs": {"IY": "Screen buffer"}}, "name": "clearBuffer", "description": "Turns off all pixels on a screen buffer."}, "allocScreenBuffer": {"path": "kernel/src/00/memory.asm", "line": 14, "sections": {"Outputs": {"IY": "Screen buffer"}}, "name": "allocScreenBuffer", "description": "Allocates a 768-byte screen buffer."}, "putSprite16XOR": {"path": "kernel/src/00/display.asm", "line": 585, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16XOR", "description": "Draws a 16xB sprite on the screen buffer using XOR (invert) logic."}}, "Miscellaneous": {"rleCompress": {"path": "kernel/src/02/compression.asm", "line": 4, "sections": {"Inputs": {"DE": "Destination, cannot (yet) be the same location as original data", "HL": "Data to compress", "BC": "Size of uncompressed data"}, "Outputs": {"BC": "Size of compressed data", "AF": "Destroyed"}}, "name": "rleCompress", "description": "Compresses data using a simple Run-Length-Encoding scheme. All bytes in a compressed block are treated as literal, except the two following a sentinel byte (selected because of its low occurance in z80 code), which specify the length of the run and the byte to run with, respectively."}, "rleCalculateCompressedLength": {"path": "kernel/src/02/compression.asm", "line": 90, "sections": {"Inputs": {"HL": "Data to compress", "BC": "Size of decompressed data"}, "Outputs": {"BC": "Size of compressed data", "AF": "Destroyed"}}, "name": "rleCalculateCompressedLength", "description": "Calculates the size of data resulting from a compression, but does not actually compress anything."}, "hexToA": {"path": "kernel/src/00/util.asm", "line": 92, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"A": "Value"}}, "name": "hexToA", "description": "Converts a hexadecimal string to a number."}, "getKernelPatchNumber": {"path": "kernel/src/00/util.asm", "line": 365, "sections": {"Outputs": {"Z": "set on success, reset on error", "HL": "patch number"}}, "name": "getKernelPatchNumber", "description": "Returns the kernel's patch number."}, "getKernelCommitsSinceTag": {"path": "kernel/src/00/util.asm", "line": 386, "sections": {"Outputs": {"Z": "set on success, reset on error", "HL": "number of commits"}}, "name": "getKernelCommitsSinceTag", "description": "Returns how many commits have been made since the last kernel tag."}, "hexToHL": {"path": "kernel/src/00/util.asm", "line": 52, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"HL": "Value"}}, "name": "hexToHL", "description": "Converts a hexadecimal string to a number."}, "getKernelMajorVersion": {"path": "kernel/src/00/util.asm", "line": 334, "sections": {"Outputs": {"Z": "set on success, reset on error", "HL": "major version number"}}, "name": "getKernelMajorVersion", "description": "Returns the kernel's major version number."}, "rleCalculateDecompressedLength": {"path": "kernel/src/02/compression.asm", "line": 213, "sections": {"Inputs": {"HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Destroyed"}}, "name": "rleCalculateDecompressedLength", "description": "Calculates the size of data resulting from a decompression, but does not actually decompress anything."}, "randA": {"path": "kernel/src/00/util.asm", "line": 180, "sections": {"Inputs": {"A'": "seed"}, "Outputs": {"A": "random byte", "A'": "reseeded"}}, "name": "randA", "description": "Returns a random byte in A."}, "isKernelDirty": {"path": "kernel/src/00/util.asm", "line": 459, "sections": {"Outputs": {"Z": "set if dirty"}}, "name": "isKernelDirty", "description": "Tests if the kernel is dirty, i.e if it has uncommited changes."}, "getKernelMinorVersion": {"path": "kernel/src/00/util.asm", "line": 347, "sections": {"Outputs": {"Z": "set on success, reset on error", "HL": "minor version number"}}, "name": "getKernelMinorVersion", "description": "Returns the kernel's minor version number."}, "callbackSort": {"path": "kernel/src/02/sort.asm", "line": 54, "sections": {"Inputs": {"IX": "Pointer to comparison function.", "DE": "Last element in array", "HL": "First element in array", "BC": "Size of element in bytes"}, "Notes": "\n The comparison function must affect the carry flag like cp (hl), (de) \n would.  (That is, set the carry flag if (HL) < (DE).)  All other registers \n must be preserved.  The algorithm (quicksort) uses an average of O(log n) \n stack space, with 8 bytes stack per recursion required.  Quicksort is \n in-place and is not a stable sort."}, "name": "callbackSort", "description": "Sorts an array of arbitrarily-sized blocks using a callback function to perform comparisons."}, "indirect16HLDE": {"path": "kernel/src/00/util.asm", "line": 241, "sections": {"Notes": "\n This routine is useful as part of a callback for the callbackSort routine."}, "name": "indirect16HLDE", "description": "Performs HL = (HL) and DE = (DE)."}, "indirect16HL": {"path": "kernel/src/00/util.asm", "line": 251, "sections": {}, "name": "indirect16HL", "description": "Performs HL = (HL)"}, "getBatteryLevel": {"path": "kernel/src/00/util.asm", "line": 137, "sections": {"Outputs": {"B": "Battery level"}, "Notes": "\n For 15MHz CPUs, B is a value from 0 to 4, where 0 is critical and 4 is full. \n For 6MHz CPUs, B is either 0 or 1, where 0 is critical and 1 is good."}, "name": "getBatteryLevel", "description": "Determines the approximate battery level."}, "integerSort": {"path": "kernel/src/02/sort.asm", "line": 1, "sections": {"Inputs": {"DE": "Last element in array", "HL": "first element in array"}, "Notes": "\n This routine is an in-place version of a radix sort, which has an O(k*n) \n runtime for k-bit numbers.  It also requires a smaller, fixed amount of \n stack space."}, "name": "integerSort", "description": "Sorts a specified array of 8-bit numbers using a fast (time complexity O(n)) algorithm."}, "sleep": {"path": "kernel/src/00/util.asm", "line": 280, "sections": {"Inputs": {"HL": "delay in milliseconds"}, "Notes": "\n 117 or 121 T-states are added when called in 6 MHz mode to the delayed time, \n depending on the interrupt state upon calling."}, "name": "sleep", "description": "Delays a number of milliseconds."}, "getBootCodeVersionString": {"path": "kernel/src/00/util.asm", "line": 149, "sections": {"Outputs": {"HL": "String pointer"}, "Notes": "\n This allocates memory to hold the string. Deallocate it with [[free]] when you no longer need it."}, "name": "getBootCodeVersionString", "description": "Gets the version string from the device's boot code."}, "rleDecompress": {"path": "kernel/src/02/compression.asm", "line": 157, "sections": {"Inputs": {"DE": "Destination, cannot be the same location as original data", "HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Destroyed"}}, "name": "rleDecompress", "description": "Decompresses data compressed with the algorithm used by the kernel routine rleCompress.  See its documentation for algorithm details."}, "cpHLDE_sort": {"path": "kernel/src/00/util.asm", "line": 262, "sections": {"Inputs": {"DE": "Pointer to integer", "HL": "Pointer to integer"}, "Notes": "\n This routine is extremely useful as the callback for the [[callbackSort]] routine. \n It allows sorting a list of 16-bit numbers.", "Output": "\n Flags: Same as z80 CP instruction."}, "name": "cpHLDE_sort", "description": "Compares 16-bit integers at (HL) and (DE).  That is, calls indirect16HLDE, then calls cpHLDE."}, "getKernelShortHash": {"path": "kernel/src/00/util.asm", "line": 411, "sections": {"Outputs": {"Z": "set on success, reset on error", "HL": "pointer on short hash string"}, "Notes": "\n Make sure to free HL after you're done with the string. Failure \n to do so will result in memory leaks !!"}, "name": "getKernelShortHash", "description": "Returns the kernel's short hash, copied to malloc-ed RAM."}}, "Hardware": {"getIOLock": {"path": "kernel/src/00/locks.asm", "line": 13, "sections": {}, "name": "getIOLock", "description": "Locks the I/O port to the current thread."}, "getKeypadLock": {"path": "kernel/src/00/locks.asm", "line": 22, "sections": {}, "name": "getKeypadLock", "description": "Locks the keyboard to the current thread."}, "hasIOLock": {"path": "kernel/src/00/locks.asm", "line": 53, "sections": {}, "name": "hasIOLock", "description": "Sets Z if the current thread has a lock on the I/O port."}, "hasLCDLock": {"path": "kernel/src/00/locks.asm", "line": 40, "sections": {}, "name": "hasLCDLock", "description": "Sets Z if the current thread has a lock on the LCD."}, "hasKeypadLock": {"path": "kernel/src/00/locks.asm", "line": 66, "sections": {}, "name": "hasKeypadLock", "description": "Sets Z if the current thread has a lock on the keyboard."}, "getUSBLock": {"path": "kernel/src/00/locks.asm", "line": 31, "sections": {}, "name": "getUSBLock", "description": "Locks the USB port to the current thread."}, "getLcdLock": {"path": "kernel/src/00/locks.asm", "line": 1, "sections": {}, "name": "getLcdLock", "description": "Locks the LCD to the current thread."}, "hasUSBLock": {"path": "kernel/src/00/locks.asm", "line": 79, "sections": {}, "name": "hasUSBLock", "description": "Sets Z if the current thread has a lock on the USB."}}, "Threading": {"launchProgram": {"path": "kernel/src/00/thread.asm", "line": 310, "sections": {"Inputs": {"DE": "Path to executable file"}, "Notes": "\n Call this with interrupts disabled if you wish to manipulate the thread \n before it starts (for example, to set the initial value of the registers). \n See [[startThread]] for details.", "Outputs": {"A": "Thread ID (on success), error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "launchProgram", "description": "Loads the specified file into memory as a program and starts a new thread for it. The file must be a valid KEXC executable."}, "setInitialHL": {"path": "kernel/src/00/thread.asm", "line": 673, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of HL"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialHL", "description": "Sets the initial value of the HL register for the specified thread."}, "setReturnPoint": {"path": "kernel/src/00/thread.asm", "line": 597, "sections": {"Inputs": {"A": "Thread ID", "HL": "Return point"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setReturnPoint", "description": "Sets the return point for the specified thread. This is set to [[killThread]] by default."}, "setInitialIX": {"path": "kernel/src/00/thread.asm", "line": 725, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IX"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIX", "description": "Sets the initial value of the IX register for the specified thread."}, "getHeaderValue": {"path": "kernel/src/00/thread.asm", "line": 488, "sections": {"Inputs": {"A": "Thread ID", "B": "Header"}, "Outputs": {"A": "Preserved unless error", "Z": "Set if found, reset if not", "HL": "Header value"}}, "name": "getHeaderValue", "description": "Finds a header in the specified thread, and returns its value."}, "killCurrentThread": {"path": "kernel/src/00/thread.asm", "line": 122, "sections": {"Notes": "\n In most cases, it is preferrable to call [[exitThread]], which will use \n the exit function specified by the caller. \n \n \n This function cleans up all resources owned by that thread, including \n allocated memory, loaded libraries, file handles, etc."}, "name": "killCurrentThread", "description": "Kills the currently executing thread."}, "suspendCurrentThread": {"path": "kernel/src/00/thread.asm", "line": 792, "sections": {"Notes": "\n This function will not return until a second thread resumes the current thread."}, "name": "suspendCurrentThread", "description": "Suspends the currently executing thread."}, "setInitialDE": {"path": "kernel/src/00/thread.asm", "line": 647, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of DE"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialDE", "description": "Sets the initial value of the DE register for the specified thread."}, "setInitialA": {"path": "kernel/src/00/thread.asm", "line": 699, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "H": "Initial value of A"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialA", "description": "Sets the initial value of the A register for the specified thread."}, "getEntryPoint": {"path": "kernel/src/00/thread.asm", "line": 438, "sections": {"Inputs": {"A": "Thread ID"}, "Outputs": {"HL": "Entry point"}}, "name": "getEntryPoint", "description": "Retrieves the entry point for the specified thread."}, "killThread": {"path": "kernel/src/00/thread.asm", "line": 198, "sections": {"Inputs": {"A": "Thread ID"}, "Notes": "\n This function cleans up all resources owned by that thread, including \n allocated memory, loaded libraries, file handles, etc.", "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "killThread", "description": "Kills the specified thread."}, "setInitialIY": {"path": "kernel/src/00/thread.asm", "line": 751, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IY"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIY", "description": "Sets the initial value of the IY register for the specified thread."}, "setInitialBC": {"path": "kernel/src/00/thread.asm", "line": 621, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of BC"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialBC", "description": "Sets the initial value of the BC register for the specified thread."}, "getThreadEntry": {"path": "kernel/src/00/thread.asm", "line": 456, "sections": {"Inputs": {"A": "Thread ID"}, "Notes": "\n You must disable interrupts while manipulating the thread table to \n guarantee that it will not change while you do so. \n \n \n Programs that manipulate the thread table directly should force a \n specific major kernel version, as this is liable to change between \n versions.", "Outputs": {"HL": "Thread entry"}}, "name": "getThreadEntry", "description": "Gets a pointer to the specified thread's entry in the thread table."}, "startThread": {"path": "kernel/src/00/thread.asm", "line": 32, "sections": {"Inputs": {"A": "Thread flags", "B": "Desired stack size / 2", "HL": "Pointer to thread executable"}, "Notes": "\n If you wish to manipulate this thread before it executes (to set the initial value \n of the registers, for instance), disable interrupts before calling startThread, and \n re-enable them when you're ready to start the thread. If you want to postpone \n starting the thread for an extended period of time, call [[suspendThread]] before \n re-enabling interrupts, and [[resumeThread]] when you're ready to start it.", "Outputs": {"A": "ID of new thread (on success); Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "startThread", "description": "Starts a new thread."}, "readSignal": {"path": "kernel/src/00/signals.asm", "line": 65, "sections": {"Outputs": {"B": "Message type", "Z": "Set if a signal was read, reset if there are no pending signals", "HL": "Message payload"}}, "name": "readSignal", "description": "Reads the next pending signal from this thread's signal queue."}, "exitThread": {"path": "kernel/src/00/thread.asm", "line": 415, "sections": {"Notes": "\n This is preferred to [[killCurrentThread]], since it will go through the caller-set \n exit function. This is often [[killCurrentThread]] anyway, but it may be set to a \n custom value by the code that intitialized the thread."}, "name": "exitThread", "description": "Immediately terminates the running thread."}, "createSignal": {"path": "kernel/src/00/signals.asm", "line": 8, "sections": {"Inputs": {"A": "Target thread ID", "B": "Message type", "HL": "Message payload"}, "Notes": "\n The receiving thread may use [[readSignal]] to consume this \n message."}, "name": "createSignal", "description": "Signals another thread with a simple message."}, "getCurrentThreadID": {"path": "kernel/src/00/thread.asm", "line": 16, "sections": {"Outputs": {"A": "Thread ID"}}, "name": "getCurrentThreadID", "description": "Gets the ID of the currently executing thread."}, "resumeThread": {"path": "kernel/src/00/thread.asm", "line": 810, "sections": {"Inputs": {"A": "Thread ID"}}, "name": "resumeThread", "description": "Resumes the specified thread."}}, "Filesystem": {"fileExists": {"path": "kernel/src/00/filesystem.asm", "line": 41, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "fileExists", "description": "Determines if a file exists."}, "formatUnusedPages": {"path": "kernel/src/00/filesystem.asm", "line": 967, "sections": {"Notes": "\n This function is only relevant to system-level programmers. \n Most programmers do not have to concern themselves with it."}, "name": "formatUnusedPages", "description": "If /bin/init is called with A set to 0xFF, this function should be called. It may be appropriate to show the user some sort of UI while this is processing, as it will take some time to run."}, "findDirectoryEntry": {"path": "kernel/src/00/filesystem.asm", "line": 833, "sections": {"Inputs": {"DE": "Path to directory"}, "Notes": "\n This function returns HL=0 for the root directory. You should \n handle this special case yourself. The root directory has ID 0 \n and has no parent directory.", "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "findDirectoryEntry", "description": "Finds a directory entry in the FAT."}, "findFileEntry": {"path": "kernel/src/00/filesystem.asm", "line": 693, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "findFileEntry", "description": "Finds a file entry in the FAT."}, "directoryExists": {"path": "kernel/src/00/filesystem.asm", "line": 63, "sections": {"Inputs": {"DE": "Path to directory (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "directoryExists", "description": "Determines if a directory exists."}, "listDirectory": {"path": "kernel/src/00/filesystem.asm", "line": 85, "sections": {"Inputs": {"DE": "Path to directory", "HL": "Callback"}, "Notes": "\n This function will call your callback every time it encounters a \n relevant entry on the filesystem. You are free to use IX, IY, and \n the shadow registers in this callback, but must preserve all other \n registers. Your function will be called with the following state: \n \n * HL: Address of entry \n * BC: Length of entry \n * A: Type of entry \n * kernelGarbage: Name of entry \n * Correct page swapped into bank A \n * Interrupts disabled (do not enable them) \n \n You must leave these registers intact.", "Outputs": {"A": "Error code on failure, preserved on success", "Z": "Set on success, reset on failure"}}, "name": "listDirectory", "description": "Lists the contents of a directory on the filesystem."}, "renameFile": {"path": "kernel/src/00/filesystem.asm", "line": 1036, "sections": {"Inputs": {"DE": "Path to file (string pointer)", "HL": "New filename"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set if the file was renamed, reset if file did not exist"}}, "name": "renameFile", "description": "Renames a file."}, "createDirectory": {"path": "kernel/src/00/filesystem.asm", "line": 598, "sections": {"Inputs": {"DE": "Path to new directory"}, "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "createDirectory", "description": "Creates a new directory in the filesystem and returns information about the new filesystem entry."}, "deleteFile": {"path": "kernel/src/00/filesystem.asm", "line": 1, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set if file was deleted, reset if file did not exist"}}, "name": "deleteFile", "description": "Deletes a file."}}, "Maths": {"mul16By8": {"path": "kernel/src/00/math.asm", "line": 88, "sections": {"Inputs": {"A": "Multiplier", "DE": "Multiplicand"}, "Outputs": {"AHL": "Product of A and DE."}}, "name": "mul16By8", "description": "Performs an unsigned multiplication of A and DE."}, "sdivACbyDE": {"path": "kernel/src/00/math.asm", "line": 469, "sections": {"Output": "\n AC: AC / DE \n HL: Remainder", "Notes": "\n B is destroyed"}, "name": "sdivACbyDE", "description": "Performs `AC = AC / DE`. The operation is signed."}, "cpHLDE": {"path": "kernel/src/00/math.asm", "line": 1, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpHLDE", "description": "Compares HL to DE."}, "smax": {"path": "kernel/src/00/math.asm", "line": 531, "sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the smallest of the previous HL and DE", "HL": "the largest of the previous HL and DE"}}, "name": "smax", "description": "Returns the largest between HL and DE. The operation is signed."}, "cpBCDE": {"path": "kernel/src/00/math.asm", "line": 19, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpBCDE", "description": "Compares DE to BC."}, "mul32By8": {"path": "kernel/src/00/math.asm", "line": 166, "sections": {"Outputs": {"DEHL": "product of DEHL and A"}}, "name": "mul32By8", "description": "Performs an unsigned multiplication of DEHL and A."}, "div8by8": {"path": "kernel/src/00/math.asm", "line": 229, "sections": {"Outputs": {"A": "Remainder", "D": "D / E"}}, "name": "div8by8", "description": "Performs `D = D / E`"}, "cpHLBC": {"path": "kernel/src/00/math.asm", "line": 10, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpHLBC", "description": "Compares HL to BC."}, "divACByDE": {"path": "kernel/src/00/math.asm", "line": 348, "sections": {"Outputs": {"AC": "AC / DE", "HL": "Remainder"}}, "name": "divACByDE", "description": "Performs `AC = AC / DE`"}, "div32By16": {"path": "kernel/src/00/math.asm", "line": 201, "sections": {"Outputs": {"B": "0", "HL": "Remainder", "ACIX": "ACIX / DE"}}, "name": "div32By16", "description": "Performs `ACIX = ACIX / DE`"}, "divHLByC": {"path": "kernel/src/00/math.asm", "line": 329, "sections": {"Outputs": {"A": "Remainder", "HL": "HL / C"}}, "name": "divHLByC", "description": "Performs `HL = HL / C`"}, "sub16From32": {"path": "kernel/src/00/math.asm", "line": 287, "sections": {}, "name": "sub16From32", "description": "Performs `ACIX = ACIX - DE`"}, "mul8By8": {"path": "kernel/src/00/math.asm", "line": 56, "sections": {"Inputs": {"H": "Multiplier", "E": "Multiplicand"}, "Outputs": {"HL": "Product of H and E."}}, "name": "mul8By8", "description": "Performs an unsigned multiplication of H and E"}, "add16To32": {"path": "kernel/src/00/math.asm", "line": 310, "sections": {}, "name": "add16To32", "description": "Performs `ACIX = ACIX + DE`"}, "smul16By8": {"path": "kernel/src/00/math.asm", "line": 32, "sections": {"Inputs": {"A": "Multiplier", "DE": "Multiplicand"}, "Outputs": {"HL": "Product of A and DE."}}, "name": "smul16By8", "description": "Performs a signed multiplication of A and DE."}, "isin": {"path": "kernel/src/00/math.asm", "line": 551, "sections": {"Inputs": {"A": "angle"}, "Notes": "\n To fit assembly, both the input and output have an uncommon format : \n the input angle has a period of 256, and the outputted value will \n be in the range [-64, 64] instead of [-1,1].", "Outputs": {"A": "sine of the angle, scaled to 64"}}, "name": "isin", "description": "Returns the sine of the given angle."}, "icos": {"path": "kernel/src/00/math.asm", "line": 565, "sections": {"Inputs": {"A": "angle"}, "Notes": "\n To fit assembly, both the input and output have an uncommon format : \n the input angle has a period of 256, and the outputted value will \n be in the range [-63, 63] instead of [-1,1].", "Outputs": {"A": "sine of the angle, scaled to 64"}}, "name": "icos", "description": "Returns the cosine of the given angle."}, "mul16By16": {"path": "kernel/src/00/math.asm", "line": 123, "sections": {"Inputs": {"DE": "Multiplier", "BC": "Multiplicand"}, "Outputs": {"DEHL": "Product of DE and BC."}}, "name": "mul16By16", "description": "Performs an unsigned multiplication of DE and BC."}, "smin": {"path": "kernel/src/00/math.asm", "line": 511, "sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the largest of the previous HL and DE", "HL": "the smallest of the previous HL and DE"}}, "name": "smin", "description": "Returns the smallest between HL and DE. The operation is signed."}}, "Input": {"flushKeys": {"path": "kernel/src/00/keyboard.asm", "line": 19, "sections": {}, "name": "flushKeys", "description": "Blocks until all keys are released."}, "getKey": {"path": "kernel/src/00/keyboard.asm", "line": 43, "sections": {"Outputs": {"A": "Key code"}}, "name": "getKey", "description": "Returns the currently pressed key code, or zero if no keys are pressed."}, "waitKey": {"path": "kernel/src/00/keyboard.asm", "line": 1, "sections": {"Outputs": {"A": "Key code"}}, "name": "waitKey", "description": "Blocks until a key is pressed, then returns that key code."}}, "Strings": {"strchr": {"path": "kernel/src/00/strings.asm", "line": 85, "sections": {"Inputs": {"B": "character to search", "HL": "string pointer"}, "Notes": "\n Destroys A", "Outputs": {"Z": "set if character found", "HL": "pointer on first occurence of character in string in case of success"}}, "name": "strchr", "description": "Returns a pointer on the first occurence of a character in a string."}, "strtoi": {"path": "kernel/src/00/strings.asm", "line": 108, "sections": {"Inputs": {"B": "maximum number of digits to convert", "HL": "pointer on ASCII-encoded decimal"}, "Notes": "\n The routine will ignore leading zeroes to produce a number composed by a  \n maximum of 10 digits, the maximal value being 4,294,967,295. If a 10-digits \n number with a greater value is encountered, no error will be thrown but the \n number won't be converted as expected. \n Besides, the routine supports negative numbers that starts with the character '-'. \n This character has no effect on the number of digits parsed. \n Destroys BC', DE' and HL'.", "Outputs": {"DEHL": "converted word", "Z": "set on success, reset on error"}}, "name": "strtoi", "description": "Converts an ASCII-encoded signed decimal into a word of variable size."}, "strcpy": {"path": "kernel/src/00/strings.asm", "line": 66, "sections": {"Inputs": {"DE": "Destination", "HL": "String pointer"}}, "name": "strcpy", "description": "Copies a string."}, "strlen": {"path": "kernel/src/00/strings.asm", "line": 1, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"BC": "String length"}}, "name": "strlen", "description": "Determines the length of a zero delimited string."}, "strcmp": {"path": "kernel/src/00/strings.asm", "line": 21, "sections": {"Inputs": {"DE": "String pointer", "HL": "String pointer"}, "Outputs": {"C": "Set if string HL is alphabetically earlier than string DE", "Z": "Set if equal, reset if not equal"}}, "name": "strcmp", "description": "Determines if two strings are equal, and checks alphabetical sort order."}, "strcmp_sort": {"path": "kernel/src/00/strings.asm", "line": 45, "sections": {"Inputs": {"DE": "Pointer to string pointer", "HL": "Pointer to string pointer"}, "Notes": "\n This routine is extremely useful as the callback for the [[callbackSort]] routine. \n It allows sorting a list of pointers to strings by the strings' sort order.", "Outputs": {"C": "Set if string (HL) is alphabetically earlier than string (DE)", "Z": "Set if equal, reset if not equal"}}, "name": "strcmp_sort", "description": "Compares strings at ((HL)) and ((DE)).  That is, calls indirect16HLDE, then calls strcmp."}}, "Filestreams": {"getStreamBuffer": {"path": "kernel/src/00/filestreams.asm", "line": 406, "sections": {"Inputs": {"D": "Stream ID"}, "Notes": "\n For read-only streams, modifying this buffer could have unforseen consequences and it will not be copied back to the file. \n For writable streams, make sure you call [[flush]] if you modify this buffer and want to make the changes persist to the file.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Stream buffer (on success)"}}, "name": "getStreamBuffer", "description": "Gets the address of a stream's memory buffer."}, "getStreamEntry": {"path": "kernel/src/00/filestreams.asm", "line": 429, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "IX": "File stream entry poitner (on success)", "Z": "Set on success, reset on failure"}}, "name": "getStreamEntry", "description": "Gets the address of a stream entry in the kernel file stream table. Note that it is almost always better to use the kernel functions for getting data out of this, because the internal struct layout may change between kernel releases."}, "streamReadBuffer": {"path": "kernel/src/00/filestreams.asm", "line": 1092, "sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID", "BC": "Length"}, "Notes": "\n If BC is greater than the remaining space in the stream, the stream will be advanced to the end \n before returning an error.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadBuffer", "description": "Reads a number of bytes from a file stream and advances the stream."}, "openFileWrite": {"path": "kernel/src/00/filestreams.asm", "line": 145, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileWrite", "description": "Opens a file stream in write mode. If the file does not exist, it is created."}, "closeStream": {"path": "kernel/src/00/filestreams.asm", "line": 466, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "closeStream", "description": "Closes an open stream."}, "streamReadByte": {"path": "kernel/src/00/filestreams.asm", "line": 953, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Data read (on success); Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadByte", "description": "Reads a single byte from a file stream and advances the stream."}, "openFileRead": {"path": "kernel/src/00/filestreams.asm", "line": 1, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileRead", "description": "Opens a file stream in read-only mode."}, "flush": {"path": "kernel/src/00/filestreams.asm", "line": 703, "sections": {"Inputs": {"D": "Stream ID"}, "Notes": "\n This happens periodically as you write to the stream, and happens \n automatically on closeStream. Try not to use it unless you have to.", "Outputs": {"A": "Preserved on success; error code on error", "Z": "Set on success, reset on error"}}, "name": "flush", "description": "Flushes pending writes to disk."}, "streamReadToEnd": {"path": "kernel/src/00/filestreams.asm", "line": 1338, "sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadToEnd", "description": "Reads the remainder of a file stream into memory."}, "streamReadWord": {"path": "kernel/src/00/filestreams.asm", "line": 1064, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Data read (on success)"}}, "name": "streamReadWord", "description": "Reads a 16-bit word from a file stream and advances the stream."}, "getStreamInfo": {"path": "kernel/src/00/filestreams.asm", "line": 1239, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "EBC": "Remaining space in stream (on success)"}}, "name": "getStreamInfo", "description": "Gets the amount of space remaining in a file stream."}}}